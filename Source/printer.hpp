#pragma once

/*
99% of this file was generated by ChatGPT.
*/


// CLSIDs / IIDs (from MSDN, hardcoded)
static const CLSID CLSID_WiaDevMgr = { 0xA1F4E726, 0x8CF1, 0x11D1, {0xBF,0x92,0x00,0x60,0x08,0x1E,0x4F,0x8F} };
static const CLSID CLSID_WiaItem = { 0x2CBAA2C0, 0x3E4C, 0x11D3, {0xB5,0xEE,0x00,0xC0,0x4F,0x68,0x4D,0xB6} };
static const IID IID_IWiaDevMgr = { 0x5EB2502A, 0x8CF1, 0x11D1, {0xBF,0x92,0x00,0x60,0x08,0x1E,0x4F,0x8F} };

SDL_Surface* SurfaceFromBMPMemory(void* data, size_t size)
{
    SDL_RWops* rw = SDL_RWFromMem(data, (int)size);
    if (!rw) { return nullptr; }

    SDL_Surface* surf = SDL_LoadBMP_RW(rw, 1);
    return surf;
}

SDL_Surface* ScanToSDLSurface()
{
    HRESULT hr = CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);
    if (FAILED(hr)) { return nullptr; }

    //avoids error: "transfer of control bypasses initialization of:".
    goto jump_over_failed;
failed:
    CoUninitialize();
    return nullptr;
jump_over_failed:


    IDispatch* devMgr = nullptr;

    hr = CoCreateInstance(
        CLSID_WiaDevMgr,
        nullptr,
        CLSCTX_LOCAL_SERVER,
        IID_IDispatch,
        (void**)&devMgr
    );

    if (FAILED(hr)) { goto failed; }

    // Call: CreateDevice(0, &device)
    DISPID dispid;
    OLECHAR* name = (OLECHAR*)L"CreateDevice";

    hr = devMgr->GetIDsOfNames(
        IID_NULL, &name, 1,
        LOCALE_USER_DEFAULT, &dispid
    );

    if (FAILED(hr)) { goto failed; }

    VARIANTARG args[2];
    VariantInit(&args[0]);
    VariantInit(&args[1]);

    args[0].vt = VT_DISPATCH | VT_BYREF;
    args[0].ppdispVal = nullptr;

    args[1].vt = VT_I4;
    args[1].lVal = 0; // default device

    DISPPARAMS params{};
    params.rgvarg = args;
    params.cArgs = 2;

    VARIANT result;
    VariantInit(&result);

    hr = devMgr->Invoke(
        dispid,
        IID_NULL,
        LOCALE_USER_DEFAULT,
        DISPATCH_METHOD,
        &params,
        &result,
        nullptr,
        nullptr
    );

    if (FAILED(hr) || result.vt != VT_DISPATCH) { goto failed; }

    IDispatch* device = result.pdispVal;

    // Call: TakePicture()
    name = (OLECHAR*)L"TakePicture";
    hr = device->GetIDsOfNames(IID_NULL, &name, 1, LOCALE_USER_DEFAULT, &dispid);
    if (FAILED(hr)) { goto failed; }

    DISPPARAMS noArgs{};
    VariantClear(&result);

    hr = device->Invoke(
        dispid,
        IID_NULL,
        LOCALE_USER_DEFAULT,
        DISPATCH_METHOD,
        &noArgs,
        &result,
        nullptr,
        nullptr
    );

    if (FAILED(hr) || result.vt != VT_DISPATCH) { goto failed; }

    IDispatch* imageFile = result.pdispVal;

    // Call: FileData.BinaryData
    name = (OLECHAR*)L"FileData";
    hr = imageFile->GetIDsOfNames(IID_NULL, &name, 1, LOCALE_USER_DEFAULT, &dispid);
    if (FAILED(hr)) { goto failed; }

    VariantClear(&result);

    hr = imageFile->Invoke(
        dispid,
        IID_NULL,
        LOCALE_USER_DEFAULT,
        DISPATCH_PROPERTYGET,
        &noArgs,
        &result,
        nullptr,
        nullptr
    );

    if (FAILED(hr) || result.vt != VT_DISPATCH) { goto failed; }

    IDispatch* fileData = result.pdispVal;

    name = (OLECHAR*)L"BinaryData";
    hr = fileData->GetIDsOfNames(IID_NULL, &name, 1, LOCALE_USER_DEFAULT, &dispid);
    if (FAILED(hr)) { goto failed; }

    VariantClear(&result);

    hr = fileData->Invoke(
        dispid,
        IID_NULL,
        LOCALE_USER_DEFAULT,
        DISPATCH_PROPERTYGET,
        &noArgs,
        &result,
        nullptr,
        nullptr
    );

    if (FAILED(hr) || result.vt != (VT_ARRAY | VT_UI1)) { goto failed; }

    SAFEARRAY* sa = result.parray;

    void* data = nullptr;
    SafeArrayAccessData(sa, &data);

    LONG lbound, ubound;
    SafeArrayGetLBound(sa, 1, &lbound);
    SafeArrayGetUBound(sa, 1, &ubound);

    size_t size = ubound - lbound + 1;

    SDL_Surface* surf = SurfaceFromBMPMemory(data, size);

    SafeArrayUnaccessData(sa);
    VariantClear(&result);

    CoUninitialize();
    return surf;
}
void printer_error()
{
    //https://learn.microsoft.com/en-us/windows/win32/Debug/retrieving-the-last-error-code
    // Retrieve the system error message for the last-error code
    LPVOID lpMsgBuf;
    DWORD dw = GetLastError();

    if (FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dw,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&lpMsgBuf,
        0, NULL) == 0) {
        MessageBox(NULL, TEXT("FormatMessage failed"), TEXT("Error"), MB_OK);
        ExitProcess(dw);
    }

    MessageBox(NULL, (LPCTSTR)lpMsgBuf, TEXT("Error"), MB_OK);

    LocalFree(lpMsgBuf);
    ExitProcess(dw);
}
void print_text(const char* document_name, const char *msg)
{
    //Font name
    const char* font_name = "Arial";

    // Get default printer name
    DWORD size = 0;
    GetDefaultPrinterA(nullptr, &size);

    std::string printerName(size, '\0');
    GetDefaultPrinterA(&printerName[0], &size);

    // Create printer device context
    HDC hdc = CreateDCA("WINSPOOL", printerName.c_str(), nullptr, nullptr);
    if (!hdc)
    {
        printer_error();
        return;
    }

    // Describe the print job
    DOCINFO docInfo = {};
    docInfo.cbSize = sizeof(DOCINFO);
    docInfo.lpszDocName = document_name;

    //
    int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
    int dpiY = GetDeviceCaps(hdc, LOGPIXELSY);

    int physicalWidth = GetDeviceCaps(hdc, PHYSICALWIDTH);
    int physicalHeight = GetDeviceCaps(hdc, PHYSICALHEIGHT);

    int printableWidth = GetDeviceCaps(hdc, HORZRES);
    int printableHeight = GetDeviceCaps(hdc, VERTRES);

    int offsetX = GetDeviceCaps(hdc, PHYSICALOFFSETX);
    int offsetY = GetDeviceCaps(hdc, PHYSICALOFFSETY);

    // Example: 12pt font (Word default)
    int fontSizePt = 12;

    // Negative height = character height in logical units
    //thomas: changed to positive
    int fontHeight = +MulDiv(fontSizePt, dpiY, 72);

    int marginLeft = dpiX;
    int marginTop = dpiY;
    int marginRight = dpiX;
    int marginBottom = dpiY;

    // Start printing
    if (StartDocA(hdc, &docInfo) > 0)
    {
        StartPage(hdc);

        // Optional: set font
        HFONT font = CreateFontA(
            fontHeight, 0, 0, 0,
            FW_NORMAL,
            FALSE, FALSE, FALSE,
            DEFAULT_CHARSET,
            OUT_OUTLINE_PRECIS,
            CLIP_DEFAULT_PRECIS,
            CLEARTYPE_QUALITY,
            VARIABLE_PITCH,
            font_name
        );

        HFONT oldFont = (HFONT)SelectObject(hdc, font);

        // Position text (in logical units)
        TextOutA(hdc, marginLeft-offsetX, marginTop-offsetY, msg, strlen(msg));

        SelectObject(hdc, oldFont);
        DeleteObject(font);

        EndPage(hdc);
        EndDoc(hdc);
    }

    DeleteDC(hdc);
}
void print_image(const char *document_name, SDL_Surface *surf, bool vflip=1, bool dry_run=1, const char *msg="")
{
    // Get default printer name
    DWORD size = 0;
    GetDefaultPrinterA(nullptr, &size);

    std::string printerName(size, '\0');
    GetDefaultPrinterA(&printerName[0], &size);

    // Create printer device context
    HDC hdc = CreateDCA("WINSPOOL", printerName.c_str(), nullptr, nullptr);
    if (!hdc)
    {
        printf("printer error: !hdc\n");
        printer_error();
        return;
    }

    // --- Printer capabilities ---
    int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
    int dpiY = GetDeviceCaps(hdc, LOGPIXELSY);

    int printableW = GetDeviceCaps(hdc, HORZRES);
    int printableH = GetDeviceCaps(hdc, VERTRES);

    int offsetX = GetDeviceCaps(hdc, PHYSICALOFFSETX);
    int offsetY = GetDeviceCaps(hdc, PHYSICALOFFSETY);

    // --- Destination rectangle ---
    // Scale square image to full printable width
    int destW = printableW;
    int destH = printableW; // square scaling

    // Top-left of printable area
    int destX = +offsetX;
    int destY = +offsetY;

    int marginLeft = dpiX;
    int marginTop = dpiY;
    int marginRight = dpiX;
    int marginBottom = dpiY;

    // Example: 12pt font (Word default)
    int fontSizePt = 48;
    // Negative height = character height in logical units
    //thomas: changed to positive
    int fontHeight = +MulDiv(fontSizePt, dpiY, 72);

    if (0) { printf("printer capabilities:\ndpiX=%i\ndpiY=%i\nprintableW=%i\nprintableH=%i\noffsetX=%i\noffsetY=%i\n", dpiX, dpiY, printableW, printableH, offsetX, offsetY); }

    // --- SDL surface must be 32-bit ---
    SDL_Surface* src = surf;
    //SDL_SaveBMP(surf, "bilde-1.bmp");

    SDL_Surface* converted = nullptr;
    //if (surf->format->BitsPerPixel != 32)
    if (0)
    {
        converted = SDL_ConvertSurfaceFormat(
            surf,
            SDL_PIXELFORMAT_BGRA32,
            0
        );
        src = converted;
        //SDL_SaveBMP(converted, "bilde-2.bmp");
        printf("surf was concerted!\n");
    }

    surface_swap_red_blue(src);
    if (vflip) { surface_flip_v(src); }
    surface_pixel_replace(src, 0x00000000, 0xFFFFFFFF);
    //SDL_SaveBMP(src, "bilde-3.bmp");


    // --- GDI bitmap info ---
    BITMAPINFO bmi = {};
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = src->w;
    bmi.bmiHeader.biHeight = -src->h; // top-down bitmap
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    // Describe the print job
    DOCINFO docInfo = {};
    docInfo.cbSize = sizeof(DOCINFO);
    docInfo.lpszDocName = document_name;



    // Start printing
    if (not dry_run)
    {
        if (StartDocA(hdc, &docInfo) > 0)
        {
            StartPage(hdc);

            // --- Draw image ---
            StretchDIBits(
                hdc,
                destX, destY, destW, destH,   // destination (printer units)
                0, 0, src->w, src->h,         // source (image pixels)
                src->pixels,
                &bmi,
                DIB_RGB_COLORS,
                SRCCOPY
            );

            //Text.
            HFONT font = CreateFontA(
                fontHeight, 0, 0, 0,
                FW_NORMAL,
                FALSE, FALSE, FALSE,
                DEFAULT_CHARSET,
                OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,
                CLEARTYPE_QUALITY,
                VARIABLE_PITCH,
                "Arial"
            );

            HFONT oldFont = (HFONT)SelectObject(hdc, font);

            // Position text (in logical units)
            TextOutA(hdc, marginLeft - offsetX, marginBottom - offsetY * 2, msg, strlen(msg));

            SelectObject(hdc, oldFont);
            DeleteObject(font);

            //Finish.
            EndPage(hdc);
            EndDoc(hdc);
        }
        DeleteDC(hdc);
    }
    
    if (converted) { SDL_FreeSurface(converted); }
}

SDL_Surface* scanner_get()
{
    return ScanToSDLSurface();
    /*
    CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

    IWiaDevMgr* mgr = nullptr;
    CoCreateInstance(CLSID_WiaDevMgr, nullptr,
        CLSCTX_LOCAL_SERVER,
        IID_IWiaDevMgr, (void**)&mgr);

    IEnumWIA_DEV_INFO* enumInfo = nullptr;
    mgr->EnumDeviceInfo(WIA_DEVINFO_ENUM_LOCAL, &enumInfo);

    IWiaPropertyStorage* props = nullptr;
    ULONG fetched = 0;
    enumInfo->Next(1, &props, &fetched);

    BSTR deviceId = nullptr;
    PROPSPEC spec = { PRSPEC_PROPID, WIA_DIP_DEV_ID };
    PROPVARIANT var;
    PropVariantInit(&var);

    props->ReadMultiple(1, &spec, &var);
    deviceId = SysAllocString(var.bstrVal);

    IWiaItem* root = nullptr;
    mgr->CreateDevice(deviceId, &root);

    // Transfer to BMP
    IWiaDataTransfer* transfer = nullptr;
    root->QueryInterface(IID_IWiaDataTransfer, (void**)&transfer);

    // You get BMP bytes here via callback...
    // Assume bmpData / bmpSize
    void* bmpData = 0;
    int bmpSize = 0;

    SDL_RWops* rw = SDL_RWFromMem(bmpData, bmpSize);
    SDL_Surface* surface = SDL_LoadBMP_RW(rw, 1);

    CoUninitialize();
    return surface;
    /**/
}
